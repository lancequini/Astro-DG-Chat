<!DOCTYPE html>
<!--
  THIS IS NOT THE INTERESTING FILE

  This is just some UI code. There's nothing interesting and unique in this file. The interesting
  thing about this demo is the server side, which is in chat.mjs.

  WARNING: This was written by a systems engineer, not a web developer. It's probably bad.
-->

<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<!--===================================================================================-->
<!-- Inline style to avoid an extra round trip before the page can render. -->
<style type="text/css">
* {
  box-sizing: border-box;
}
body {
  font-family: Arial, Helvetica, sans-serif;
}

#chatlog {
  position: fixed;
  top: 0;
  bottom: 32px;
  left: 0;
  right: 200px;
  overflow-y: auto;
  padding: 8px;
  overflow-wrap: break-word;
  background-color: #121212
}
#chatlog span.username {
  font-weight: bold;
}

/* Message container alignment*/
.message-self {
  text-align: right;
}

.message-other {
  text-align: left;
}

/* Common bubble shape */
.message-bubble {
  display: inline-block;
  padding: 6px 10px;
  border-radius: 12px;
  max-width: 70%;
  word-wrap: break-word;
}

/* Logged-in user: light blue bubble */
.message-self .message-bubble {
  background-color: #2b79c2; /* light blue */
  color: #ffffff;
}

/* Other users: grey bubble */
.message-other .message-bubble {
  background-color: #7d7d7d; /* light grey */
  color: #e8e8e8;
}

/* Make the timestamp slightly dimmer/smaller */
.message-timestamp {
  color: #cdcdcd;        /* dim color */
  font-size: 0.55em;   /* slightly smaller */
}

.date-separator {
  text-align: center;
  margin: 30px 0;
  font-size: 0.9em;
  color: #666;
}

#spacer {
  height: calc(100vh - 32px - 5em);
  background-color: #121212;
}

#roster {
  font-weight: bold;
  padding: 8px;
}

p {
  margin-top: 0;
  margin-bottom: 8px;
}
p:last-of-type {
  margin: 0;
}

#roster {
  position: fixed;
  right: 0;
  top: 0;
  bottom: 32px;
  width: 200px;
  border-left: none;
  color: #898989;
  background-color: #121212;
}

::-webkit-scrollbar {
  display: none;
}

@media(max-width:600px) {
  #roster { display: none; }
  #chatlog { right: 0; }
}

#chat-input {
  position: fixed;
  width: 100%;
  height: 32px;
  bottom: 0;
  left: 0;
  border: none;
  border-top: none;
  padding-left: 32px;
  outline: none;
  color: #7d7d7d;
  background-color: #121212;
}
#chatroom::before {
  z-index: 1;
  display: block;
  content: ">";
  position: fixed;
  bottom: 0;
  left: 0;
  width: 32px;
  height: 32px;
  line-height: 32px;
  text-align: center;
  font-weight: bold;
  color: #888;
  background-color: #121212;
  -webkit-text-stroke-width: 2px;
}

#name-form {
  position: fixed;
  z-index: 3;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  color: #7d7d7d;
  background-color: #121212;
}

#name-input {
  position: fixed;
  font-size: 200%;
  top: calc(50% - 1em);
  left: calc(50% - 8em);
  width: 16em;
  height: 2em;
  margin: 0;
  text-align: center;
  border: 1px solid #bbb;
  color: #7d7d7d;
  background-color: #121212;
}

#name-form p {
  position: fixed;
  top: calc(50% + 3em);
  width: 100%;
  text-align: center;
}

#room-form {
  position: fixed;
  z-index: 2;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  color: #7d7d7d;
  background-color: #121212;
  font-size: 200%;
  margin-top: calc(50vh - 3em);
  text-align: center;
}

#room-name {
  font-size: inherit;
  border: 1px solid #bbb;
  height: 2em;
  width: 16em;
  padding-left: 1em;
  color: #7d7d7d;
}

#room-form button {
  font-size: inherit;
  border: 1px solid #bbb;
  background-color: #eee;
  height: 2em;
}

@media(max-width:660px) {
  #name-input, #room-form { font-size: 150%; }
  #name-form p { font-size: 75%; }
}
@media(max-width:500px) {
  #name-input, #room-form { font-size: 100%; }
  #name-form p { font-size: 50%; }
}

#go-public {
  width: 4em;
}
#go-private {
  width: 20em;
}

</style>

<!--===================================================================================-->
<!-- The actual HTML. There is not much of it. -->

  </head>
  <!--
    <div class="internal-links" style="width: 600px; margin-left: auto; margin-right: auto; font-weight: bold; font-size: 2em;">
      <a href="https://damagedgoods.me" target="_blank">Home</a>
      <a href="https://chitchatter.im/private/52a30f89-16ec-4533-8329-f100f62ea620" target="_blank">Chatter</a>
      <a href="https://damagedgoods.me" target="_blank">Shop (Coming Soon!)</a>
    </div>
  -->
  <body style="background-color: #121212;">
    <form id="name-form" action="/fake-form-action">
      <p style="font-weight: bold; font-size: 1.4em; color:#7d7d7d;">Chat App (BETA)</p>
      <input id="name-input" placeholder="Enter your name...">
    </form>
    <form id="room-form" action="/fake-form-action">
      <p>Enter a public room:</p>
      <input id="room-name" placeholder="room name"><button id="go-public">Go &raquo;</button>
      <p>OR</p>
      <button id="go-private">Create a Private Room &raquo;</button>
    </form>
    <form id="chatroom" action="/fake-form-action">
      <div id="chatlog">
        <div id="spacer"></div>
      </div>
      <div id="roster"></div>
      <input id="chat-input">
    </form>
  </body>

<!--===================================================================================-->
<!-- Client-side JavaScript code for the app. -->

<script type="text/javascript">
let currentWebSocket = null;

let nameForm = document.querySelector("#name-form");
let nameInput = document.querySelector("#name-input");
let roomForm = document.querySelector("#room-form");
let roomNameInput = document.querySelector("#room-name");
let goPublicButton = document.querySelector("#go-public");
let goPrivateButton = document.querySelector("#go-private");
let chatroom = document.querySelector("#chatroom");
let chatlog = document.querySelector("#chatlog");
let chatInput = document.querySelector("#chat-input");
let roster = document.querySelector("#roster");

// Is the chatlog scrolled to the bottom?
let isAtBottom = true;

// Date variable used for determining if the previous message was from the same day.
let lastRenderedDate = null; // e.g. "2026-01-07"

let username;
let roomname;

let hostname = window.location.host;
if (hostname == "") {
  // Probably testing the HTML locally.
  hostname = "edge-chat-demo.cloudflareworkers.com";
}

function startNameChooser() {
  nameForm.addEventListener("submit", event => {
    event.preventDefault();
    username = nameInput.value;
    if (username.length > 0) {
      startRoomChooser();
    }
  });

  nameInput.addEventListener("input", event => {
    if (event.currentTarget.value.length > 32) {
      event.currentTarget.value = event.currentTarget.value.slice(0, 32);
    }
  });

  nameInput.focus();
}

function startRoomChooser() {
  nameForm.remove();

  if (document.location.hash.length > 1) {
    roomname = document.location.hash.slice(1);
    startChat();
    return;
  }

  roomForm.addEventListener("submit", event => {
    event.preventDefault();
    roomname = roomNameInput.value;
    if (roomname.length > 0) {
      startChat();
    }
  });

  roomNameInput.addEventListener("input", event => {
    if (event.currentTarget.value.length > 32) {
      event.currentTarget.value = event.currentTarget.value.slice(0, 32);
    }
  });

  goPublicButton.addEventListener("click", event => {
    roomname = roomNameInput.value;
    if (roomname.length > 0) {
      startChat();
    }
  });

  goPrivateButton.addEventListener("click", async event => {
    roomNameInput.disabled = true;
    goPublicButton.disabled = true;
    event.currentTarget.disabled = true;

    let response = await fetch("https://" + hostname + "/api/room", {method: "POST"});
    if (!response.ok) {
      alert("something went wrong");
      document.location.reload();
      return;
    }

    roomname = await response.text();
    startChat();
  });

  roomNameInput.focus();
}

function startChat() {
  roomForm.remove();

  // Normalize the room name a bit.
  roomname = roomname.replace(/[^a-zA-Z0-9_-]/g, "").replace(/_/g, "-").toLowerCase();

  if (roomname.length > 32 && !roomname.match(/^[0-9a-f]{64}$/)) {
    addChatMessage("ERROR", "Invalid room name.");
    return;
  }

  document.location.hash = "#" + roomname;

  chatInput.addEventListener("keydown", event => {
    if (event.keyCode == 38) {
      // up arrow
      chatlog.scrollBy(0, -50);
    } else if (event.keyCode == 40) {
      // down arrow
      chatlog.scrollBy(0, 50);
    } else if (event.keyCode == 33) {
      // page up
      chatlog.scrollBy(0, -chatlog.clientHeight + 50);
    } else if (event.keyCode == 34) {
      // page down
      chatlog.scrollBy(0, chatlog.clientHeight - 50);
    }
  });

  chatroom.addEventListener("submit", event => {
    event.preventDefault();

    if (currentWebSocket) {
      currentWebSocket.send(JSON.stringify({message: chatInput.value}));
      chatInput.value = "";

      // Scroll to bottom whenever sending a message.
      chatlog.scrollBy(0, 1e8);
    }
  });

  chatInput.addEventListener("input", event => {
    if (event.currentTarget.value.length > 256) {
      event.currentTarget.value = event.currentTarget.value.slice(0, 256);
    }
  });

  chatlog.addEventListener("scroll", event => {
    isAtBottom = chatlog.scrollTop + chatlog.clientHeight >= chatlog.scrollHeight;
  });

  chatInput.focus();
  document.body.addEventListener("click", event => {
    // If the user clicked somewhere in the window without selecting any text, focus the chat
    // input.
    if (window.getSelection().toString() == "") {
      chatInput.focus();
    }
  });

  // Detect mobile keyboard appearing and disappearing, and adjust the scroll as appropriate.
  if('visualViewport' in window) {
    window.visualViewport.addEventListener('resize', function(event) {
      if (isAtBottom) {
        chatlog.scrollBy(0, 1e8);
      }
    });
  }

  join();
}

let lastSeenTimestamp = 0;
let wroteWelcomeMessages = false;

function join() {
  // If we are running via wrangler dev, use ws:
  const wss = document.location.protocol === "http:" ? "ws://" : "wss://";
  let ws = new WebSocket(wss + hostname + "/api/room/" + roomname + "/websocket");
  let rejoined = false;
  let startTime = Date.now();

  let rejoin = async () => {
    if (!rejoined) {
      rejoined = true;
      currentWebSocket = null;

      // Clear the roster.
      while (roster.firstChild) {
        roster.removeChild(roster.firstChild);
      }

      // Don't try to reconnect too rapidly.
      let timeSinceLastJoin = Date.now() - startTime;
      if (timeSinceLastJoin < 10000) {
        // Less than 10 seconds elapsed since last join. Pause a bit.
        await new Promise(resolve => setTimeout(resolve, 10000 - timeSinceLastJoin));
      }

      // OK, reconnect now!
      join();
    }
  }

  ws.addEventListener("open", event => {
    currentWebSocket = ws;

    // Send user info message.
    ws.send(JSON.stringify({name: username}));
  });

  ws.addEventListener("message", event => {
    let data = JSON.parse(event.data);

    if (data.error) {
      addChatMessage(null, "* Error: " + data.error, null);
    } else if (data.joined) {
      let p = document.createElement("p");
      p.innerText = data.joined;
      roster.appendChild(p);
    } else if (data.quit) {
      for (let child of roster.childNodes) {
        if (child.innerText == data.quit) {
          roster.removeChild(child);
          break;
        }
      }
    } else if (data.ready) {
      // All pre-join messages have been delivered.
      if (!wroteWelcomeMessages) {
        wroteWelcomeMessages = true;

        //Scrolls to the bottom of the page on initial load.
        chatlog.scrollTop = chatlog.scrollHeight;
        isAtBottom = true;
        
        //  addChatMessage(null,
        //    "* This is a demo app built with Cloudflare Workers Durable Objects. The source code " +
        //    "can be found at: https://github.com/cloudflare/workers-chat-demo");
        //addChatMessage(null,
        //    "* WARNING: Participants in this chat are random people on the internet. " +
        //   "Names are not authenticated; anyone can pretend to be anyone. The people " +
        //    "you are chatting with are NOT Cloudflare employees. Chat history is saved.");
        if (roomname.length == 64) {
          addChatMessage(null,
        //      "* This is a private room. You can invite someone to the room by sending them the URL.");
        "");
        } else {
          addChatMessage(null,
        //      "* Welcome to #" + roomname + ". Say hi!");
        "");
        }
      }
    } else {
      // A regular chat message.
      if (data.timestamp > lastSeenTimestamp) {
        addChatMessage(data.name, data, data.timestamp);
        lastSeenTimestamp = data.timestamp;
      }
    }
  });

  ws.addEventListener("close", event => {
    console.log("WebSocket closed, reconnecting:", event.code, event.reason);
    rejoin();
  });
  ws.addEventListener("error", event => {
    console.log("WebSocket error, reconnecting:", event);
    rejoin();
  });
}

function isValidTimestamp(t) {
  return typeof t === "number" && !isNaN(t);
}

function addChatMessage(name, payloadOrText, time) {

  // Insert a date separator if this message is more than a day old.
  const dateKey = getDateKeyFromTimestamp(time);
  if (dateKey && dateKey !== lastRenderedDate) {
    lastRenderedDate = dateKey;
    insertDateSeparator(time);
  }

  const isSelf = (typeof name === "string" && name.length > 0 && username === name);

  const p = document.createElement("p");
  p.classList.add(isSelf ? "message-self" : "message-other");

  const hasValidTime = typeof time === "number" && !isNaN(time);
  const hasName = typeof name === "string" && name.length > 0;

  const text = typeof payloadOrText === "string"
    ? payloadOrText
    : (payloadOrText && payloadOrText.message) || "";

  // Skips empty messages. Handles a bug where an empty message is created on initial login.
  if (!text || !text.trim()) {
    return;
  }

  // Bubble element
  const bubble = document.createElement("span");
  bubble.classList.add("message-bubble");


  if (isSelf) {
    // Self: text + timestamp inside the bubble, no username
    const textSpan = document.createElement("span");
    appendMessageWithLinks(textSpan, text);
    bubble.appendChild(textSpan);

    if (hasValidTime) {
      const ts = new Date(time);
      if (!isNaN(ts.getTime())) {
        const selfTime = document.createElement("span");
        selfTime.className = "message-timestamp";
        selfTime.innerText = "\n[" + ts.toLocaleTimeString() + "]";
        bubble.appendChild(selfTime);
      }
    }
  } else if (hasName) {
    const nameSpan = document.createElement("span");
    nameSpan.className = "username";
    nameSpan.innerText = name + ": ";
    bubble.appendChild(nameSpan);

    appendMessageWithLinks(bubble, text);

        // Others: [timestamp] username: text inside the bubble
    if (hasValidTime) {
      const ts = new Date(time);
      if (!isNaN(ts.getTime())) {
        const timeSpan = document.createElement("span");
        timeSpan.className = "message-timestamp";
        timeSpan.innerText = "\n[" + ts.toLocaleTimeString() + "] ";
        bubble.appendChild(timeSpan);
      }
    }
  } else {
    // System/date messages: no bubble color change, or you can skip bubble entirely
    appendMessageWithLinks(bubble, text);
  }

  p.appendChild(bubble);
  
  chatlog.appendChild(p);

  if (isAtBottom) {
    chatlog.scrollBy(0, 1e8);
  }
}


function appendMessageWithLinks(container, text) {
  // Regex: basic URL detection (http/https)
  const urlRegex = /(https?:\/\/[^\s]+)/g;

  let lastIndex = 0;
  let match;

  while ((match = urlRegex.exec(text)) !== null) {
    const url = match[0];

    // Text before the URL (always plain text)
    if (match.index > lastIndex) {
      const before = text.slice(lastIndex, match.index);
      container.appendChild(document.createTextNode(before));
    }

    // The URL itself (hyperlinked)
    const a = document.createElement("a");
    a.href = url;
    a.innerText = url;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    container.appendChild(a);

    lastIndex = match.index + url.length;
  }

  // Remaining text after the last URL
  if (lastIndex < text.length) {
    container.appendChild(document.createTextNode(text.slice(lastIndex)));
  }
}

function insertDateSeparator(time) {
  const label = getDateLabelFromTimestamp(time);
  if (!label) return;

  const div = document.createElement("div");
  div.className = "date-separator";
  div.innerText = label;

  chatlog.appendChild(div);
}


function getDateKeyFromTimestamp(time) {
  if (typeof time !== "number" || isNaN(time)) return null;
  const d = new Date(time);
  if (isNaN(d.getTime())) return null;

  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

// Returns a string like "Jan 7, 2026" for use in a date separator
function getDateLabelFromTimestamp(time) {
  const d = new Date(time);
  if (isNaN(d.getTime())) return "";

  const options = {
    year: "numeric",
    month: "short", // e.g. "Jan"
    day: "numeric"
  };

  // Example output: "Jan 7, 2026" in an en-US locale
  return d.toLocaleDateString("en-US", options);
}



// Direct room access if name parameter exists is the URL
if (document.location.hash.length > 1) {
  const urlParams = new URLSearchParams(window.location.search);
  
  // ONLY skip forms if ?name= exists in URL
  if (urlParams.has('name')) {
    username = urlParams.get('name').slice(0, 32) || "Guest";
    roomname = document.location.hash.slice(1);
    
    // Hide forms and jump to chat
    nameForm.style.display = "none";
    roomForm.style.display = "none";
    startChat();
  } else {
    // No name param = show name chooser normally
    startNameChooser();
  }
} else {
  startNameChooser();
}


</script>
<!--===================================================================================-->
</html>
